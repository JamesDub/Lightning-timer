<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lightning Timer - LightningMaps.org Data</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #map {
      height: 40vh;
      width: 100%;
    }
    #timer {
      font-size: 8vw;
      margin-top: 0.5em;
    }
    #status {
      font-size: 4vw;
      margin-bottom: 1em;
    }
    .on {
      color: red;
    }
    .off {
      color: lightgreen;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="timer">--:--</div>
  <div id="status" class="off">Waiting for lightning...</div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const STRIKES_LIST_KEY = "strikes_list";
    let radiusMiles = 10;
    let radiusKm = radiusMiles * 1.60934;
    const timerEl = document.getElementById('timer');
    const statusEl = document.getElementById('status');
    let userLat = null, userLon = null;

    const map = L.map('map').setView([0, 0], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    const userMarker = L.marker([0, 0]).addTo(map);
    let circle = L.circle([0, 0], { radius: radiusKm * 1000, color: 'cyan' }).addTo(map);
    const strikesLayer = L.layerGroup().addTo(map);

    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371; // km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function updateTimerDisplay(secondsLeft) {
      let m = Math.floor(secondsLeft / 60);
      let s = Math.floor(secondsLeft % 60);
      timerEl.textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      if (secondsLeft > 0) {
        statusEl.textContent = "âš¡ Sorry, we are on lightning";
        statusEl.className = "on";
      } else {
        statusEl.textContent = "Lightning tracker and countdown";
        statusEl.className = "off";
      }
    }

    function clearStrikesLayer() {
      strikesLayer.clearLayers();
    }

    function drawStrikesOnMap(strikes) {
      strikes.forEach(s => {
        L.circleMarker([s.lat, s.lon], {
          radius: 4,
          color: 'yellow',
          fillColor: 'yellow',
          fillOpacity: 0.8
        }).addTo(strikesLayer);
      });
    }

    function loadStoredStrikes() {
      const strikes = JSON.parse(localStorage.getItem(STRIKES_LIST_KEY) || "[]");
      const now = Date.now();
      const validStrikes = strikes.filter(s => now - s.time <= 1800000);
      localStorage.setItem(STRIKES_LIST_KEY, JSON.stringify(validStrikes));
      return validStrikes;
    }

    // Fetch lightning strikes from LightningMaps Blitzortung last_30.json feed
    async function fetchLightningStrikes() {
      try {
        // LightningMaps last_30.json URL
        const url = "https://www.lightningmaps.org/blitzortung/data/last_30.json";

        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP error ${res.status}`);

        const data = await res.json();

        // Data format: { "flashes": [ [lon, lat, timestamp, ...], ... ] }
        const flashes = data.flashes || [];

        const now = Date.now();
        let strikes = JSON.parse(localStorage.getItem(STRIKES_LIST_KEY) || "[]");

        flashes.forEach(flash => {
          const lon = flash[0];
          const lat = flash[1];
          const timeSec = flash[2]; // timestamp in seconds
          const timeMs = timeSec * 1000;

          // Check if strike is recent (< 30 mins) and inside radius
          if (now - timeMs <= 1800000) {
            if (userLat !== null && userLon !== null) {
              const distKm = haversine(userLat, userLon, lat, lon);
              if (distKm <= radiusKm) {
                // Check if this strike already exists (avoid duplicates)
                if (!strikes.some(s => s.lat === lat && s.lon === lon && s.time === timeMs)) {
                  strikes.push({ lat, lon, time: timeMs });
                  console.log(`New strike at ${lat},${lon} within radius (${distKm.toFixed(2)} km)`);
                }
              }
            }
          }
        });

        // Remove old strikes (> 30 mins)
        strikes = strikes.filter(s => now - s.time <= 1800000);

        localStorage.setItem(STRIKES_LIST_KEY, JSON.stringify(strikes));

        clearStrikesLayer();
        drawStrikesOnMap(strikes);

      } catch (e) {
        console.error("Error fetching lightning strikes:", e);
      }
    }

    function checkTimer() {
      const strikes = JSON.parse(localStorage.getItem(STRIKES_LIST_KEY) || "[]");
      const now = Date.now();
      const recentStrikes = strikes.filter(s => now - s.time <= 1800000);

      if (recentStrikes.length > 0) {
        const lastStrikeTime = new Date(Math.max(...recentStrikes.map(s => s.time)));
        const elapsed = (now - lastStrikeTime.getTime()) / 1000;
        const remaining = Math.max(0, 1800 - elapsed);
        updateTimerDisplay(remaining);
      } else {
        timerEl.textContent = "--:--";
        statusEl.textContent = "Waiting for lightning...";
        statusEl.className = "off";
      }
    }

    function init() {
      if (!navigator.geolocation) {
        alert("Geolocation is required for this app.");
        return;
      }

      navigator.geolocation.getCurrentPosition(pos => {
        userLat = pos.coords.latitude;
        userLon = pos.coords.longitude;

        userMarker.setLatLng([userLat, userLon]);
        circle.setLatLng([userLat, userLon]);
        map.setView([userLat, userLon], 10);

        const userRadius = prompt("Enter radius in miles (default is 10):", "10");
        if (userRadius && !isNaN(userRadius)) {
          radiusMiles = parseFloat(userRadius);
          radiusKm = radiusMiles * 1.60934;
          circle.setRadius(radiusKm * 1000);
        }

        // Initial fetch
        fetchLightningStrikes();

        // Poll every 20 seconds
        setInterval(fetchLightningStrikes, 20000);

        // Update timer every second
        setInterval(checkTimer, 1000);
      }, err => {
        alert("Failed to get location: " + err.message);
      });
    }

    window.onload = init;
  </script>
</body>
</html>
