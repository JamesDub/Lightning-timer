<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lightning Timer</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin: 0; background: #111; color: #fff; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    #map { height: 40vh; width: 100%; }
    #timer { font-size: 8vw; margin-top: 0.5em; }
    #status { font-size: 4vw; margin-bottom: 1em; }
    .on { color: red; }
    .off { color: lightgreen; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="timer">--:--</div>
  <div id="status" class="off">Waiting for lightning...</div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const LAST_STRIKE_KEY = "last_strike_utc";
    const STRIKES_LIST_KEY = "strikes_list";
    let radiusMiles = 10;
    let radiusKm = radiusMiles * 1.60934;
    const timerEl = document.getElementById('timer');
    const statusEl = document.getElementById('status');
    let userLat = 0, userLon = 0;

    const map = L.map('map').setView([0, 0], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    const marker = L.marker([0, 0]).addTo(map);
    let circle = L.circle([0, 0], { radius: radiusKm * 1000, color: 'cyan' }).addTo(map);
    const strikesLayer = L.layerGroup().addTo(map);

    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function updateTimerDisplay(secondsLeft) {
      let m = Math.floor(secondsLeft / 60);
      let s = Math.floor(secondsLeft % 60);
      timerEl.textContent = `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
      if (secondsLeft > 0) {
        statusEl.textContent = "\u26A1 Sorry, we are on lightning";
        statusEl.className = "on";
      } else {
        statusEl.textContent = "Lightning tracker and countdown";
        statusEl.className = "off";
      }
    }

    function checkTimer() {
      const strikes = JSON.parse(localStorage.getItem(STRIKES_LIST_KEY) || "[]");
      const now = Date.now();
      const recentStrikes = strikes.filter(s => now - s.time <= 1800000);
      if (recentStrikes.length > 0) {
        const last = new Date(Math.max(...recentStrikes.map(s => s.time)));
        const elapsed = (Date.now() - last.getTime()) / 1000;
        const remaining = Math.max(0, 1800 - elapsed);
        updateTimerDisplay(remaining);
      } else {
        timerEl.textContent = "--:--";
        statusEl.textContent = "Waiting for lightning...";
        statusEl.className = "off";
      }
    }

    // Blitzortung WebSocket
    const ws = new WebSocket('wss://ws.lightning.deno.dev');
    ws.onmessage = (msg) => {
      try {
        const data = JSON.parse(msg.data);
        let strikes = JSON.parse(localStorage.getItem(STRIKES_LIST_KEY) || "[]");
        const now = Date.now();

        data.forEach(strike => {
          if (strike.lat && strike.lon) {
            const d = haversine(userLat, userLon, strike.lat, strike.lon);
            if (d <= radiusKm) {
              const timestamp = Date.now();
              strikes.push({ lat: strike.lat, lon: strike.lon, time: timestamp });
              L.circleMarker([strike.lat, strike.lon], {
                radius: 4,
                color: 'yellow',
                fillColor: 'yellow',
                fillOpacity: 0.8
              }).addTo(strikesLayer);
            }
          }
        });

        // Keep only the last 30 minutes of strikes
        strikes = strikes.filter(s => now - s.time <= 1800000);
        localStorage.setItem(STRIKES_LIST_KEY, JSON.stringify(strikes));

      } catch (e) {
        console.warn("Bad data", e);
      }
    };

    // Live countdown
    setInterval(() => checkTimer(), 1000);

    // Geolocation
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(pos => {
        userLat = pos.coords.latitude;
        userLon = pos.coords.longitude;
        marker.setLatLng([userLat, userLon]);
        circle.setLatLng([userLat, userLon]);
        map.setView([userLat, userLon], 10);

        // Custom radius prompt
        const userRadius = prompt("Enter radius in miles (default is 10):", "10");
        if (userRadius && !isNaN(userRadius)) {
          radiusMiles = parseFloat(userRadius);
          radiusKm = radiusMiles * 1.60934;
          circle.setRadius(radiusKm * 1000);
        }
      });
    }
  </script>
</body>
</html>
